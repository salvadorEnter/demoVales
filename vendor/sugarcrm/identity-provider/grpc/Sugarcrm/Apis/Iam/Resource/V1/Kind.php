<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: apis/iam/resource/v1/types.proto

namespace Sugarcrm\Apis\Iam\Resource\V1;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\RepeatedField;
use Google\Protobuf\Internal\GPBUtil;

/**
 * All resources are structured in a hierarchical way which is. Note that
 * multiple hierarchical trees can be formed. The Kinds create a formal way to
 * be able to define all supported SRNs which can be used by different language
 * implementations. The different graph definition allows to resolve a given
 * kind to its root object. Currently we assume resolving through config only.
 * An example of such a tree can be:
 *                              organization
 *                                   |
 *                     +---------------------------+
 *                     |             |             |
 *                 tenant x      tenant y      tenant z
 *                     |
 *      +--------------+----------------------+------------+------------+
 *      |                                     |            |            |
 *   eventstore                            blobstore    crm prod    crm sandbox
 *      |                                     |
 *      +-------------------+          +------+------+
 *      |                   |          |             |
 *  journal x           journal y   bucket a      bucket b
 *                          |
 *                +---------+-------+
 *                |                 |
 *            stream a          stream b
 * Implementation related notes:
 * Both kind names and template variables are defined through configuration.
 * This means that consumers of the SRN implementation will refer to those.
 * When referring to a kind, it is important to verify the stability level with
 * the team who owns the kind.
 *
 * Generated from protobuf message <code>sugarcrm.apis.iam.resource.v1.Kind</code>
 */
class Kind extends \Google\Protobuf\Internal\Message
{
    /**
     * Global unique identifier for this kind. It is recommend to use human
     * readable name like: iam-user, eventstore-stream, ... Allowed characters
     * for the name are: [a-zA-z-]
     *
     * Generated from protobuf field <code>string name = 1;</code>
     */
    private $name = '';
    /**
     * The parent unique identifier. For root objects this value is empty.
     *
     * Generated from protobuf field <code>string parent = 2;</code>
     */
    private $parent = '';
    /**
     * SRN template expression. The expression language is used to define the
     * variable SRN components using `{var}`. Allowed characters are [a-zA-Z]
     * Example: srn:{partition}:service:{region}:{tenant}:user:{user-id}
     * Note that the variables names should be choosen wisely. Once a kind has
     * been defined and is stable, one should refrain from changing the names
     * of the variables as this can have adverse effects.
     * Also understand how tree resolving works to the parent. The variables
     * are propagated from the child to the parent. If no match is found, the
     * global variables are used. Therefore, it is advized to use disambiguous
     * variable names.
     * Following examples are being executed inside an application which is
     * deployed in the `us-west-2` region and partition `cloud`. The have
     * both values globally defined as {partition} and {region}. Additionally
     * the following `tenant` kind is defined:
     *  kind   = tenant
     *  tpl    = srn:{partition}:iam:{region}:{tenant}:tenant
     * Example 1:
     *  kind   = iam-app-crm
     *  tpl    = srn:{partition}:iam:{region}:{tenant}:app:crm:{id}
     *  parent = tenant
     * When resolving `srn:cloud:iam:onpremise:1234567890:app:crm:sandbox1` to
     * the tenant following the parent link, the resulting tenant is:
     * `srn:cloud:iam:onpremise:1234567890:tenant`. As all variables from the
     * child are propagated to the parent, the {region} is set to `onpremise`
     * and result in an incorrectly deducted tenant SRN.
     * Example 2:
     *  kind   = iam-app-crm
     *  tpl    = srn:{partition}:iam:{crm-region}:{tenant}:app:crm:{id}
     *  parent = tenant
     * When resolving `srn:cloud:iam:onpremise:1234567890:app:crm:sandbox1` to
     * the tenant following the parent link, the resulting tenant is:
     * `srn:cloud:iam:us-west-2:1234567890:tenant`. Because no {region} var is
     * available, the globally defined {region} is used. This gives us the
     * expected result.
     *
     * Generated from protobuf field <code>string template = 3;</code>
     */
    private $template = '';
    /**
     * Example reference SRN which comply with the above template. This is
     * primarily used for documentation purposes and can be leveraged by the
     * implementation to test for duplicate template definitions.
     *
     * Generated from protobuf field <code>repeated string references = 4;</code>
     */
    private $references;
    /**
     * Human friendly description, primarily used for documentation.
     *
     * Generated from protobuf field <code>string description = 5;</code>
     */
    private $description = '';
    /**
     * List of arbitrary labels. This can be leveraged for example to indicate
     * the maturity level or the type. Labels will also be used to be able to
     * deal with external path resolving. These will be defined at a later
     * stage (i.e. one cannot resolve a tenant to an organization using vars
     * only).
     * For example:
     *  stability=dev,stable,deprecated
     *  visibility=private,public
     *  owner=idm,evt
     *  ...
     *
     * Generated from protobuf field <code>map<string, string> labels = 6;</code>
     */
    private $labels;

    public function __construct() {
        \GPBMetadata\Apis\Iam\Resource\V1\Types::initOnce();
        parent::__construct();
    }

    /**
     * Global unique identifier for this kind. It is recommend to use human
     * readable name like: iam-user, eventstore-stream, ... Allowed characters
     * for the name are: [a-zA-z-]
     *
     * Generated from protobuf field <code>string name = 1;</code>
     * @return string
     */
    public function getName()
    {
        return $this->name;
    }

    /**
     * Global unique identifier for this kind. It is recommend to use human
     * readable name like: iam-user, eventstore-stream, ... Allowed characters
     * for the name are: [a-zA-z-]
     *
     * Generated from protobuf field <code>string name = 1;</code>
     * @param string $var
     * @return $this
     */
    public function setName($var)
    {
        GPBUtil::checkString($var, True);
        $this->name = $var;

        return $this;
    }

    /**
     * The parent unique identifier. For root objects this value is empty.
     *
     * Generated from protobuf field <code>string parent = 2;</code>
     * @return string
     */
    public function getParent()
    {
        return $this->parent;
    }

    /**
     * The parent unique identifier. For root objects this value is empty.
     *
     * Generated from protobuf field <code>string parent = 2;</code>
     * @param string $var
     * @return $this
     */
    public function setParent($var)
    {
        GPBUtil::checkString($var, True);
        $this->parent = $var;

        return $this;
    }

    /**
     * SRN template expression. The expression language is used to define the
     * variable SRN components using `{var}`. Allowed characters are [a-zA-Z]
     * Example: srn:{partition}:service:{region}:{tenant}:user:{user-id}
     * Note that the variables names should be choosen wisely. Once a kind has
     * been defined and is stable, one should refrain from changing the names
     * of the variables as this can have adverse effects.
     * Also understand how tree resolving works to the parent. The variables
     * are propagated from the child to the parent. If no match is found, the
     * global variables are used. Therefore, it is advized to use disambiguous
     * variable names.
     * Following examples are being executed inside an application which is
     * deployed in the `us-west-2` region and partition `cloud`. The have
     * both values globally defined as {partition} and {region}. Additionally
     * the following `tenant` kind is defined:
     *  kind   = tenant
     *  tpl    = srn:{partition}:iam:{region}:{tenant}:tenant
     * Example 1:
     *  kind   = iam-app-crm
     *  tpl    = srn:{partition}:iam:{region}:{tenant}:app:crm:{id}
     *  parent = tenant
     * When resolving `srn:cloud:iam:onpremise:1234567890:app:crm:sandbox1` to
     * the tenant following the parent link, the resulting tenant is:
     * `srn:cloud:iam:onpremise:1234567890:tenant`. As all variables from the
     * child are propagated to the parent, the {region} is set to `onpremise`
     * and result in an incorrectly deducted tenant SRN.
     * Example 2:
     *  kind   = iam-app-crm
     *  tpl    = srn:{partition}:iam:{crm-region}:{tenant}:app:crm:{id}
     *  parent = tenant
     * When resolving `srn:cloud:iam:onpremise:1234567890:app:crm:sandbox1` to
     * the tenant following the parent link, the resulting tenant is:
     * `srn:cloud:iam:us-west-2:1234567890:tenant`. Because no {region} var is
     * available, the globally defined {region} is used. This gives us the
     * expected result.
     *
     * Generated from protobuf field <code>string template = 3;</code>
     * @return string
     */
    public function getTemplate()
    {
        return $this->template;
    }

    /**
     * SRN template expression. The expression language is used to define the
     * variable SRN components using `{var}`. Allowed characters are [a-zA-Z]
     * Example: srn:{partition}:service:{region}:{tenant}:user:{user-id}
     * Note that the variables names should be choosen wisely. Once a kind has
     * been defined and is stable, one should refrain from changing the names
     * of the variables as this can have adverse effects.
     * Also understand how tree resolving works to the parent. The variables
     * are propagated from the child to the parent. If no match is found, the
     * global variables are used. Therefore, it is advized to use disambiguous
     * variable names.
     * Following examples are being executed inside an application which is
     * deployed in the `us-west-2` region and partition `cloud`. The have
     * both values globally defined as {partition} and {region}. Additionally
     * the following `tenant` kind is defined:
     *  kind   = tenant
     *  tpl    = srn:{partition}:iam:{region}:{tenant}:tenant
     * Example 1:
     *  kind   = iam-app-crm
     *  tpl    = srn:{partition}:iam:{region}:{tenant}:app:crm:{id}
     *  parent = tenant
     * When resolving `srn:cloud:iam:onpremise:1234567890:app:crm:sandbox1` to
     * the tenant following the parent link, the resulting tenant is:
     * `srn:cloud:iam:onpremise:1234567890:tenant`. As all variables from the
     * child are propagated to the parent, the {region} is set to `onpremise`
     * and result in an incorrectly deducted tenant SRN.
     * Example 2:
     *  kind   = iam-app-crm
     *  tpl    = srn:{partition}:iam:{crm-region}:{tenant}:app:crm:{id}
     *  parent = tenant
     * When resolving `srn:cloud:iam:onpremise:1234567890:app:crm:sandbox1` to
     * the tenant following the parent link, the resulting tenant is:
     * `srn:cloud:iam:us-west-2:1234567890:tenant`. Because no {region} var is
     * available, the globally defined {region} is used. This gives us the
     * expected result.
     *
     * Generated from protobuf field <code>string template = 3;</code>
     * @param string $var
     * @return $this
     */
    public function setTemplate($var)
    {
        GPBUtil::checkString($var, True);
        $this->template = $var;

        return $this;
    }

    /**
     * Example reference SRN which comply with the above template. This is
     * primarily used for documentation purposes and can be leveraged by the
     * implementation to test for duplicate template definitions.
     *
     * Generated from protobuf field <code>repeated string references = 4;</code>
     * @return \Google\Protobuf\Internal\RepeatedField
     */
    public function getReferences()
    {
        return $this->references;
    }

    /**
     * Example reference SRN which comply with the above template. This is
     * primarily used for documentation purposes and can be leveraged by the
     * implementation to test for duplicate template definitions.
     *
     * Generated from protobuf field <code>repeated string references = 4;</code>
     * @param string[]|\Google\Protobuf\Internal\RepeatedField $var
     * @return $this
     */
    public function setReferences($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::STRING);
        $this->references = $arr;

        return $this;
    }

    /**
     * Human friendly description, primarily used for documentation.
     *
     * Generated from protobuf field <code>string description = 5;</code>
     * @return string
     */
    public function getDescription()
    {
        return $this->description;
    }

    /**
     * Human friendly description, primarily used for documentation.
     *
     * Generated from protobuf field <code>string description = 5;</code>
     * @param string $var
     * @return $this
     */
    public function setDescription($var)
    {
        GPBUtil::checkString($var, True);
        $this->description = $var;

        return $this;
    }

    /**
     * List of arbitrary labels. This can be leveraged for example to indicate
     * the maturity level or the type. Labels will also be used to be able to
     * deal with external path resolving. These will be defined at a later
     * stage (i.e. one cannot resolve a tenant to an organization using vars
     * only).
     * For example:
     *  stability=dev,stable,deprecated
     *  visibility=private,public
     *  owner=idm,evt
     *  ...
     *
     * Generated from protobuf field <code>map<string, string> labels = 6;</code>
     * @return \Google\Protobuf\Internal\MapField
     */
    public function getLabels()
    {
        return $this->labels;
    }

    /**
     * List of arbitrary labels. This can be leveraged for example to indicate
     * the maturity level or the type. Labels will also be used to be able to
     * deal with external path resolving. These will be defined at a later
     * stage (i.e. one cannot resolve a tenant to an organization using vars
     * only).
     * For example:
     *  stability=dev,stable,deprecated
     *  visibility=private,public
     *  owner=idm,evt
     *  ...
     *
     * Generated from protobuf field <code>map<string, string> labels = 6;</code>
     * @param array|\Google\Protobuf\Internal\MapField $var
     * @return $this
     */
    public function setLabels($var)
    {
        $arr = GPBUtil::checkMapField($var, \Google\Protobuf\Internal\GPBType::STRING, \Google\Protobuf\Internal\GPBType::STRING);
        $this->labels = $arr;

        return $this;
    }

}

